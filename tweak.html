<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Accelerometer Javascript Test</title>
    <meta name=viewport content="width=device-width,user-scalable=no"/>
    <style>
      body {
/*        height: 400px;*/
/*        overflow: hidden;*/
      	font-family: helvetica, arial, sans serif;
      	margin: 0;
      }
      div {
        background-color: white;
      }
      * {
        margin: 0;
        padding: 0;
      }
      #sphere {
      	position: absolute;	
      	width: 5px;
      	height: 5px;
      	border-radius: 5px;
      	-webkit-radius: 5px;
      	background-color: blue;
      }
      
      ul { 
        margin: 4px 12px;
        list-style: none;
        font-size: 18px;
        font-weight: bold;
        color: #aaa;
        font-family: "Courier New";
      }
      li {
        margin: 0 0 0px 0;
      }
      strong {

      }
    </style>
    

    
    
    <script type="text/javascript" src="js/lib/jquery-1.7.min.js"></script>
    <script type="text/javascript" src="js/lib/underscore.js"></script>
    <script type="text/javascript" src="js/lib/backbone.js"></script>
    <script type="text/javascript" src="js/lib/json2.js"></script>
    <script type="text/javascript" src="js/lib/dataviz/jquery.sparkline.js"></script>
    
    <script type="text/javascript" src="js/utils.js"></script>
    
  </head>

<body>
  <div id="content">
    <button id="toggle_random">pause random</button>
    <div id="sphere"></div>
      <ul>
        <li>X: <div id="mouseX"><small></small><strong></strong></div></li>
        <li>Y: <div id="mouseY"><small></small><strong></strong></div></li>
        <li>random: <div id="random"><small></small><strong></strong></div></li>

        <li>color <div id="color"><strong></strong></div></li>
        
        <li>squared <div id="squared"><small></small><strong></strong></div></li>
        
        <li>x: <span id="accelerationX"></span>g <span id="ax"></span></li>
        <li>y: <span id="accelerationY"></span>g <span id="ay"></span></li>
        <li>z: <span id="accelerationZ"></span>g <span id="az"></span></li>

        <li>&nbsp;</li>
        
        <li>vx:<span id='vx'></span></li>
        <li>vy:<span id='vy'></span></li>
      </ul>
    </div>
  </div>
</body>

<script type="text/javascript">

var x = 0,  y = 0,
    vx = 0, vy = 0,
   	ax = 0, ay = 0,
   	e;
	
	
var trail = {
  ax: [],
  ay: [],
  az: []
}



	
function p (id, num, len) {
  var pad = (num >= 0) ? ('+' + num) : '' + num,
      d = pad.substr(0, len || 4);
      
	document.getElementById( id ).innerHTML = d;
}

var sphere = document.getElementById("sphere");



/* 

 [√]  multiple values input in realtime
 [√]  multiple values calculated and output in realtime
 [√]  all values remember their history and display a sparkleline
 [√]  values normalised internally ( 0 - 1.0 )
 [√]  all changes bindable

----

 [ ]  ids known so el: not needed
 [ ]  autonormalisation based on input extremes
 [ ]  bounding works 




addInput( 'mouseX', { min: 0, max: $(window).width() });
addOutput( );


*/



var Model = {};

var options = { 
  normalRangeMin: 0, normalRangeMax: 1, 
  width: '120px', chartRangeClip: true, spotColor: false,
  minSpotColor: false, maxSpotColor: false
};



Model.Var = Backbone.Model.extend({
  initHistory: function() {
    this.bind('change:value', function() {
      $(this.get('el') + " strong").text( this.get('value') + "(" + this.get('raw') + ")" );
      $(this.get('el') + " small").sparkline( this.get('history'), options );
    });
    this.set({ history: [], history_length: 50 })    
  },
  addToHistory: function(v) {
    var h = this.get('history');
    if (h.length > this.get('history_length')) {
	    h.shift();
	  }
	  h.push( v );
  }
});


Model.In = Model.Var.extend({
  defaults: { min: 0, max: 100 },
  initialize: function(options) {
    this.initHistory();
    
    if (typeof options.initial !== "undefined" && options.initial !== null) {
      this.value( options.initial );
    }
  },
  value: function(v) {
    var min = this.get('min'),
        max = this.get('max');

    if (typeof v == "undefined" || v == null) {
      return this.get('value');
    }
    
    this.set({ raw: v });

    v = Math.min(v / max, 1);
    
    this.addToHistory( v );
        
    this.set({ value: v });
  }
});

Model.Out = Model.Var.extend({
  initialize: function(attr, calculate) {
    this.initHistory();
    this.calculate = calculate;
  },
  update: function() {
    var v = this.calculate.call( vars.reals );
    this.addToHistory( v );
    this.set({ value: v });
  }
});



// .message('x')
// .listen('x y')


// 


var Vars = Backbone.Model.extend({
  initialize: function() {
    this.bind('change', function() {
      this.updateReals();
    });
    this.updateReals();
  },
  updateReals: function() {
    var that = this;
    this.reals = {};
        
    _.each(this.attributes, function(v, k) {
      that.reals[k] = v.get('value');
    });
  },
  recalculate: function() {
    _.each(this.attributes, function(v, k) {
      if (v.calculate) {
        v.update()
      }
    });
  }
});



var vars = new Vars;

vars.set({ 
  mouseX: new Model.In({ el: '#mouseX', min: 0, max: $(window).width(),  initial: 0 }),
  mouseY: new Model.In({ el: '#mouseY', min: 0, max: $(window).height(), initial: 0 }),
  random: new Model.In({ el: '#random', min: 0, max: 1,                  initial: 0.5 }),

  squared: new Model.Out({ el: "#squared" }, function() {
    return this.mouseX * this.mouseX
  }),
  color: new Model.Out( { el: '#color' }, function() {
    return "rgba(" + Math.floor(this.mouseX * 255) + ", "
                   + Math.floor(this.mouseY * 255) + ", 0, " + this.random + ")";
  })
});






vars.get('color').bind( 'change:value', function() {
  $('body').css({ backgroundColor: vars.get('color').get('value') })
});




function tick () {
  _.delay(function() {
    
    vars.updateReals();
    vars.recalculate();
    
    tick();
  }, 10);
}

tick();






$(window).mousemove(function(e) {
  vars.get('mouseX').value( e.clientX );
  vars.get('mouseY').value( e.clientY );
});

$(window).bind('touchstart', touched);
$(window).bind('touchmove', touched);
  
  
function touched (e) {
  vars.get('mouseX').value( e.originalEvent.pageX );
  vars.get('mouseY').value( e.originalEvent.pageY );
  return false;
}





function set_random () {
  _.delay(function() {
    var now = vars.get('random').value();
    set_random.on && vars.get('random').value( now + (Math.random() > 0.5 ? 0.05 : -0.05) );
    set_random();
  }, 250);
}

set_random.on = false;
set_random();

$('#toggle_random').click( function() {
  set_random.on = (! set_random.on);
})






//

function capmaker (from, to) {
  return function(num) {
    
  }
}



if (window.DeviceMotionEvent != undefined) {
	window.ondevicemotion = function(ev) {
		ax = event.accelerationIncludingGravity.x * 5;
		ay = event.accelerationIncludingGravity.y * 5;
		
		e = ev;
    // p("accelerationX", e.accelerationIncludingGravity.x);
    // p("accelerationY", e.accelerationIncludingGravity.y);
    // p("accelerationZ", e.accelerationIncludingGravity.z);
    // 
    // if ( e.rotationRate ) {
    //   p("rotationAlpha", e.rotationRate.alpha);
    //   p( "rotationBeta", e.rotationRate.beta);
    //   p("rotationGamma", e.rotationRate.gamma);
    // }
	}
	
  
  // $('body').bind('touchstart', function() {
  //   alert(trail.ax);
  // });

  var n = 0;
	setInterval( function() {
		var landscapeOrientation = window.innerWidth/window.innerHeight > 1;
		if ( landscapeOrientation) {
			vx = vx + ay;
			vy = vy + ax;
		} else {
			vy = vy - ay;
			vx = vx + ax;
		}
		vx = vx * 0.98;
		vy = vy * 0.98;
		y = parseInt(y + vy / 50);
		x = parseInt(x + vx / 50);
		
		if (n++ % 10 == 0) {
		  
		  var tmp = e.accelerationIncludingGravity;
		  
		  if (trail.ax.length > 50) {
		    trail.ax.shift()
		  }
      trail.ax.push( tmp.x );
      
		  if (trail.ay.length > 50) {
		    trail.ay.shift()
		  }
      trail.ay.push( tmp.y );
      
		  if (trail.az.length > 50) {
		    trail.az.shift()
		  }
      trail.az.push( tmp.z );
      
      		  
  		p("accelerationX", tmp.x);
  		p("accelerationY", tmp.y);
  		p("accelerationZ", tmp.z);

  		p("rotationAlpha", e.rotationRate.alpha);
  		p( "rotationBeta", e.rotationRate.beta);
  		p("rotationGamma", e.rotationRate.gamma);
  		p("vx", vx, 6);
  		p("vy", vy, 6);
  		
		}
		boundingBoxCheck();
		
		sphere.style.top = y + "px";
		sphere.style.left = x + "px";
		
		var options = { 
		  normalRangeMin: -10, normalRangeMax: 10, 
		  width: '120px', chartRangeClip: true, spotColor: false, minSpotColor: false, maxSpotColor: false
	  };
		
		$('#ax').sparkline( trail.ax, options);
		$('#ay').sparkline( trail.ay, options);
		$('#az').sparkline( trail.az, options);
		
	}, 50);
} 


function boundingBoxCheck(){
	if (x<0) { x = 0; vx = -vx / 2; }
	if (y<0) { y = 0; vy = -vy / 2; }
	if (x>document.documentElement.clientWidth-20) { x = document.documentElement.clientWidth-20; vx = -vx / 2; }
	if (y>document.documentElement.clientHeight-20) { y = document.documentElement.clientHeight-20; vy = -vy / 2; }
	
  // if (vy < 5.5 && vy > -5.5) vy = 0;
  // if (vx < 5.5 && vx > 5.5 ) vx = 0;
}

</script>

</html>

<html>

<head>
  <title>studio</title>

  <link id="studio_styles" rel="stylesheet" href="css/studio.css" type="text/css">

  <script type="text/javascript">
    studio_styles.rel = 'stylesheet/less';
    studio_styles.href = 'less/studio.less';
  </script>

	<!-- before jquery - needed to write to SVG -->
  <!-- // <script type="text/javascript" src="js/lib/meh/MochiKit/MochiKit.js"></script>   -->
  
  <script type="text/javascript" src="js/lib/less.js"></script>  
  <script type="text/javascript" src="js/lib/canvas/paper.js"></script>
  <script type="text/javascript" src="js/lib/jquery-1.7.min.js"></script>
  <script type="text/javascript" src="js/lib/underscore.js"></script>
  <script type="text/javascript" src="js/lib/backbone.js"></script>
  <script type="text/javascript" src="js/lib/json2.js"></script>
  <script type="text/javascript" src="js/lib/dataviz/jquery.sparkline.js"></script>
  <script type="text/javascript" src="js/utils.js"></script>

  <script type="text/javascript" src="js/dev.js"></script>

  <script type="text/javascript" src="js/snorkle.js"></script>

  <!-- // <script type="text/javascript" src="js/lib/canvas/SVGKit.js"></script> 
  // <script type="text/javascript" src="js/lib/canvas/SVGCanvas.js"></script> -->
  <!-- // <script type="text/javascript" src="js/lib/DAT.GUI.js"></script> -->
</head>

<body>

  <div id="control">
    zoom:
    <button id="z1">T</button>
    <button id="z2">Edit</button>
    <button id="z3">Print</button>
    
    design:
    <select>
      <option id="breton">breton</option>
      <option id="lines">lines</option>
    </select>
    <button id="pause">||</button>
    <span id="fps"></span>
  </div>
        
  <img id="t" src="images/full-white-t.png">
  <canvas id="canvas" keepalive="true" width='620' height='870'></canvas>
  
  <div id="meh"></div>
  
  <div id="editor">
  	<div class="tabs">
      <a href="#paperjs_editor">paper.js</a> <a href="#canvas_editor">canvas</a>
  	</div>
  	<div class="editor" id="paperjs_editor"></div>
  	<div class="editor" id="canvas_editor"></div>
  </div>
  
	<script type="text/javascript" src="http://localhost:8339/socket.io/socket.io.js"></script>
  
  <script src="js/lib/ace/ace-uncompressed-fix.js" type="text/javascript" charset="utf-8"></script>
  <script src="js/lib/ace/theme-twilight.js" type="text/javascript" charset="utf-8"></script>  
  <script src="js/lib/ace/mode-javascript.js" type="text/javascript" charset="utf-8"></script>


  <script type='text/javascript'>
  
  // var acc = {};
  //   
  // if (window.DeviceMotionEvent != undefined) {
  // 	  window.ondevicemotion = function(event) {
  //     acc.x = event.accelerationIncludingGravity.x;
  //     acc.y = event.accelerationIncludingGravity.y;
  //     acc.z = event.accelerationIncludingGravity.z;
  //   }
  //   
  //   window.addEventListener('deviceorientation', function(e) {
  //     acc.compass = e.webkitCompassHeading;
  //   });
    // setInterval( function() {  	
    //   	  J.get('accX').value( acc.x );
    //   	  J.get('accY').value( acc.y );		
    //   J.get('accZ').value( acc.z );
    //   
    //   // J.get('compass').value( acc.compass );
    // }, 100);
  // }
  
  // $(window).bind( 'mousemove', function(e) {
  //   J.get('mouse').value([ e.clientX, e.clientY ]);
  // });
  
  // J.addInputArray( 'mouse', { initial: 0.1 } );
  // var acc_options = { min: -10, max: 10,  initial: 0 };
  // J.addInput( 'accX', acc_options );
  // J.addInput( 'accY', acc_options );
  // J.addInput( 'accZ', acc_options );
  // J.addInput( 'compass', { min: 0, max: 360, initial: 180 } );
  
  
  window.focused = true; // really?
  window.onblur  = function() { focused = false; };
  window.onfocus = function() { focused = true; };

	function changed () {
		window.previous = {};
	}

  var J = new Snorkle({}, { change: _.throttle(changed, 100) });

  var canvas = document.getElementById('canvas');
	window.context = canvas.getContext('2d');

  canvas.resize = function(new_size) {
    var default_size = { x: 620, y: 870 },
        ratio = default_size.y / default_size.x;
    
    if (new_size.x) {
      new_size.y = new_size.x * ratio;
    } else if (new_size.y) {
      new_size.x = new_size.y / ratio;
    } else {
      new_size = default_size;
    }
    canvas.sizeRatio = new_size.x / default_size.x;
    canvas.width = new_size.x;
    canvas.height = new_size.y;
		

    changed();
  }

  canvas.resize({}); // setup


	// TODO set these up dynamically on a per design-basis
  J.addOutput( 'scale' );     J.addOutput( 'gap' );
	J.addOutput( 'fontsize');   J.addOutput( 'wtf' );
	J.addOutput( 'rand' );      J.addOutput( 'wave' );
  J.addOutput( 'C' );         J.addOutput( 'D' );
  J.addOutput( 'E' );       	J.addOutput( 'F' );

	
	if (typeof io != "undefined") {
	  var socket = io.connect('http://localhost:8339');
	  socket.on('face', function (data) {
	    var id = data.shift(),
	        t  = data.shift(),
	        face = {};

			if (data.length) {
		    _(data).each(function(v) {
		      face[ v[0].replace(/\//g, '_') ] = v.splice(1);
		    });
			} else {
				face[id.replace(/\//g, '_')] = t;
			}
      
	    J.pumpInput( face );
	  });
	}
  
  var simple_mode = false,
			save_prefix = 'design_id-', // change for each design
			editors = {
        'canvas':  { f: function() {} },
        'paperjs': { f: function() {} }
      };

  if (! simple_mode) {
    
    function code_change_for(key) {
      return function(ev) {
        var f_text = editors[key].ace.getSession().getValue();
  			var err = false;
        try {
  				editors[key].f = new Function('ev', 'n', 'with(v.inputs) { ' + f_text + ' } ');
        } catch (e) {
  				err = e;
        }
  			if (! err) {
          changed();
  			}
        localStorage.setItem(editors[key].id, f_text);
      }
    }
  
    window.onload = function() {
      var JavaScriptMode = require("ace/mode/javascript").Mode;
      
      _(editors).each(function(editor, key) {
        editor.id = save_prefix + key;
        
        var saved_f = localStorage.getItem(editor.id) || 'return 1';
        editor.ace = ace.edit( key + "_editor" );
        editor.ace.setTheme( "ace/theme/twilight" );
        var session = editor.ace.getSession();
        session.setValue( saved_f );
        session.setTabSize(2);
        session.setUseSoftTabs(true);
        
        var on_code_change = code_change_for( key );
        on_code_change();
        
        session.setMode( new JavaScriptMode() );
        
        session.on('change', on_code_change);
      });
            
      $('.tabs a').click(function() {
        var id = $(this).attr('href').substr(1)
        $('.tabs a').removeClass('active'); $(this).addClass('active');
        $('.editor').hide();
        $('.editor#'+ id).show();
        return false;
      });

      $('.tabs a:first-child').click(); // TODO remember
    };
  }
  
  
  function toggle_pause () {
    v.pause = ! v.pause;
    $('#pause').text( v.pause ? '>' : '||' );
  }
  
  $('#pause').bind('touchstart', toggle_pause);
  $('#pause').bind('mousedown', toggle_pause);
  
  $('#control button').bind('click', function() {
    $('body')[0].className = this.id;

    if (this.id == "z2" || this.id == 'z1') {
       // canvas.resize({ y: 600 });
    } else if (this.id == 'z3') {
       canvas.resize({ x: 4200 });
    }
  });
  
  var $fps = $('#fps');
	
	window.previous = {};
	
  function append_png() {
    var context = canvas.getContext("2d");
    var img     = canvas.toDataURL("image/png");
		
    // var svgContext = new SVGCanvas(this.canvas.width, this.canvas.height);
    // var oldCtx = this._context;
    // this._context = svgContext;
    // this.draw(false);
    // this._context = oldCtx;

    meh.innerHTML = '<img src="'+img+'">';
  }
	

	
  var breton_and_on = function() {
		paper.install(window);

    paper.setup(canvas); // Create an empty project and a view for the canvas

	  // https://github.com/paperjs/paper.js/issues/48
	  // SVGCanvas.prototype.transform = SVGCanvas.prototype.translate;
	  // SVGCanvas.prototype.fillText = SVGCanvas.prototype.text;
	  // 
    // paper.View.prototype.toSVG = function() {
    //   var svgContext = new SVGCanvas(this.canvas.width, this.canvas.height);
    //        var oldCtx = this._context;
    //   this._context = svgContext;  
    //   this.draw(false);  
    //   this._context = oldCtx;
    //   var serializer = new XMLSerializer(); // Optional serialization of the SVG DOM nodes
    //   return serializer.serializeToString(svgContext.svg.htmlElement);
    // };
		
		var blank = true;
		
    // draw text
	
    v = {
			inputs: J.reals,
      pause: false,
      points: 800,
      smooth: false,
      mousePos: view.center / 2
    };
	
    v.path = new Path();
		v.path.strokeWidth = 0;
    v.path.closed = false;

    v.initializePath = function (points) {      
      v.center = view.center;
      v.width  = view.size.width;
      v.height = view.size.height / 2;
			
      v.path.segments = [];
      for (var i = 0; i < points; i++) {
        var point = new Point(v.width / points * i, view.center.y);
        v.path.add(point);
      }
      v.path.fullySelected = false;
    }

    v.initializePath(v.points);

    var ev = { // TODO: sort this lot out
      count:     0,    // event.count: the number of times the frame event was fired
      time:     .1,   // event.time: the total amount of time passed since the first frame event in secs
      delta:    .1,   // event.delta: the time passed in seconds since the last frame event
      started:  12312 // Date.now() of first call
    };

    var frameRendering = [];
    
    function onFrame(event) { // replace with your own
      // if (frameRendering) return;
      
      if (v.pause || ! focused) {
        frameRendering.pop();
        return false;
      }

      // frameRendering = true;
      J.updateReals();
			
      var no_op = _.isEqual( previous, v.inputs ); // && function has not changed
      if (no_op) {
        // frameRendering = false;
        frameRendering.pop();
        return false;
      }
      
			previous = _.clone( v.inputs );

      $fps.text( shorten(1 / event.delta) );
      
      J.recalculate();
      
      for (var i = 0; i < v.points; i++) {
				v.inputs.n = i;
        var pos = editors.paperjs.f.call(v, event, i); // call with this set to p
        if (pos) {
          v.path.segments[i].point.y = pos.y * canvas.sizeRatio;
          v.path.segments[i].point.x = pos.x * canvas.sizeRatio;
        }
      }

      if (v.smooth) { v.path.smooth(); }
            
      blank = true; // add postCanvas
      return true;
    }
		
    (function animloop(){
      requestAnimFrame(animloop);
      var redraw = onFrame(ev);
      ev.count++;
      if (redraw) paper.view.draw();
    })();



		function postCanvas() {
			if (blank) {
        context.fillStyle="#000";
        context.globalCompositeOperation = "xor";
        editors.canvas.f.call(v);
			}
			blank = false;
		}

		setInterval(postCanvas, 100);
	};
	
	$(breton_and_on);
	
  </script>
</body>

</html>
